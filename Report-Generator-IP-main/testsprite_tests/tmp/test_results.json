[
  {
    "projectId": "207d7387-450f-4eb5-b33d-4ff2a1539de3",
    "testId": "5d1466a3-a7cd-4cdb-b544-60a790b6d8a7",
    "userId": "e4684458-5031-70c9-9355-46fd4a87f00e",
    "title": "TC001-verify_azure_sso_authentication_flow",
    "description": "Test the Azure SSO login initiation, callback handling, and session establishment with role-based access control to ensure secure authentication.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_verify_azure_sso_authentication_flow():\n    session = requests.Session()\n    try:\n        # Step 1: Access login page to get any cookies (if needed)\n        login_page_resp = session.get(f\"{BASE_URL}/login\", timeout=TIMEOUT)\n        assert login_page_resp.status_code == 200\n        assert \"text/html\" in login_page_resp.headers.get(\"Content-Type\", \"\")\n\n        # Step 2: Initiate Azure SSO login (POST to /auth/login) - expect 302 redirect\n        initiate_login_resp = session.post(f\"{BASE_URL}/auth/login\", allow_redirects=False, timeout=TIMEOUT)\n        assert initiate_login_resp.status_code == 302\n        assert \"Location\" in initiate_login_resp.headers\n        redirect_url = initiate_login_resp.headers[\"Location\"]\n        # The redirect location should be to an Azure SSO login URL containing 'login.microsoftonline.com' or 'azure'\n        assert redirect_url.startswith(\"https://\") and (\"login.microsoftonline.com\" in redirect_url.lower() or \"azure\" in redirect_url.lower())\n\n        # Step 3: Simulate callback from Azure after user authentication\n        callback_resp = session.get(f\"{BASE_URL}/auth/callback\", allow_redirects=False, timeout=TIMEOUT)\n        assert callback_resp.status_code == 302\n        assert \"Location\" in callback_resp.headers\n        post_auth_redirect = callback_resp.headers[\"Location\"]\n        assert post_auth_redirect.startswith(\"/\") or post_auth_redirect.startswith(\"http\")\n\n        # Step 4: After callback, access /me to confirm authenticated user and role info\n        me_resp = session.get(f\"{BASE_URL}/me\", timeout=TIMEOUT)\n        assert me_resp.status_code == 200\n        me_json = me_resp.json()\n        # Validate expected keys in user info by checking it's a dict with some string keys\n        assert isinstance(me_json, dict)\n        assert any(isinstance(v, str) for v in me_json.values())\n\n    except (requests.RequestException, AssertionError) as e:\n        raise AssertionError(f\"Azure SSO Authentication flow test failed: {e}\")\n\ntest_verify_azure_sso_authentication_flow()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 16, in test_verify_azure_sso_authentication_flow\nAssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 40, in <module>\n  File \"<string>\", line 38, in test_verify_azure_sso_authentication_flow\nAssertionError: Azure SSO Authentication flow test failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-03T13:43:30.570Z",
    "modified": "2025-09-03T13:44:38.285Z"
  },
  {
    "projectId": "207d7387-450f-4eb5-b33d-4ff2a1539de3",
    "testId": "3613ed7f-eb0f-4bb2-a5bf-327957416ae7",
    "userId": "e4684458-5031-70c9-9355-46fd4a87f00e",
    "title": "TC002-validate_type1_report_generation_workflow",
    "description": "Test the complete Type-1 report generation process including Excel file upload, screenshot upload, and report generation with correct embedding of data and images.",
    "code": "import requests\nimport os\nimport io\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_validate_type1_report_generation_workflow():\n    session = requests.Session()\n    headers = {}  # Add auth headers here if needed\n\n    # Prepare test files paths\n    excel_filename = \"test_template.xlsx\"\n    screenshot_filenames = [\"screenshot1.png\", \"screenshot2.png\"]\n\n    # Create dummy Excel file content (minimal valid Excel file content)\n    # Here we use a simple binary content to simulate an Excel file\n    excel_content = (\n        b\"PK\\x03\\x04\\x14\\x00\\x06\\x00\\x08\\x00\\x00\\x00!\\x00\\xB7\\x9D\\xB4L\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x13\\x00\\x00\\x00\"\n        b\"xl/workbook.xmlPK\\x01\\x02\\x14\\x03\\x14\\x00\\x06\\x00\\x08\\x00\\x00\\x00!\"\n        b\"\\x00\\xb7\\x9d\\xb4L\\x08\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x13\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00PK\\x05\\x06\\x00\"\n        b\"\\x00\\x00\\x00\\x01\\x00\\x01\\x00:\\x00\\x00\\x00H\\x00\\x00\\x00\\x00\\x00\"\n    )\n\n    # Create dummy screenshot content (simple PNG header)\n    screenshot_content = (\n        b\"\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x08\\x06\"\n        b\"\\x00\\x00\\x00\\x1f\\x15\\xc4\\x89\\x00\\x00\\x00\\nIDATx\\xdac`\\x00\\x00\\x00\\x02\\x00\\x01\"\n        b\"\\xe2!\\xbc\\x33\\x00\\x00\\x00\\x00IEND\\xaeB`\\x82\"\n    )\n\n    try:\n        # 1. Upload Excel file\n        files = {'file': (excel_filename, io.BytesIO(excel_content), 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')}\n        resp = session.post(f\"{BASE_URL}/type1/upload/\", files=files, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Excel upload failed: {resp.status_code}, {resp.text}\"\n        assert \"success\" in resp.text.lower() or \"uploaded\" in resp.text.lower()\n\n        # 2. Upload screenshots (multiple files)\n        files = [('files', (fn, io.BytesIO(screenshot_content), 'image/png')) for fn in screenshot_filenames]\n        resp = session.post(f\"{BASE_URL}/type1/upload-screenshots/\", files=files, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Screenshots upload failed: {resp.status_code}, {resp.text}\"\n        assert \"success\" in resp.text.lower() or \"uploaded\" in resp.text.lower()\n\n        # 3. Generate report\n        json_data = {\n            \"client_name\": \"Test Client\",\n            \"client_code\": \"TC-001\",\n            \"project_name\": \"Test Project\",\n            \"assessment_date\": \"2025-08-30\",\n            \"report_type\": \"Type-1\"\n        }\n        resp = session.post(f\"{BASE_URL}/type1/generate-report/\", json=json_data, headers={**headers, \"Content-Type\": \"application/json\"}, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Report generation failed: {resp.status_code}, {resp.text}\"\n        # Validate response content contains expected keys (could be a URL or binary report, assume JSON with report link or similar)\n        if 'application/json' in resp.headers.get('Content-Type', ''):\n            resp_json = resp.json()\n            assert any(key in resp_json for key in (\"report_url\", \"message\", \"status\")), \"Unexpected response JSON structure\"\n        else:\n            # If raw content (e.g. docx), check content length > 0\n            assert len(resp.content) > 0, \"Empty report content\"\n\n    finally:\n        # No explicit resource ID given; no deletion endpoint or resource cleanup instructed for these uploads\n        # So just end test. If a cleanup endpoint existed, implement here.\n        pass\n\ntest_validate_type1_report_generation_workflow()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 70, in <module>\n  File \"<string>\", line 39, in test_validate_type1_report_generation_workflow\nAssertionError\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-03T13:43:30.576Z",
    "modified": "2025-09-03T13:44:06.650Z"
  },
  {
    "projectId": "207d7387-450f-4eb5-b33d-4ff2a1539de3",
    "testId": "da14c1a1-20c2-4ac8-9e66-021476f3084d",
    "userId": "e4684458-5031-70c9-9355-46fd4a87f00e",
    "title": "TC003-validate_type2_report_generation_workflow",
    "description": "Test the complete Type-2 report generation process including Excel file upload, screenshot upload, and report generation with correct embedding of data and images.",
    "code": "import requests\nfrom requests.exceptions import RequestException, Timeout\nimport io\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef validate_type2_report_generation_workflow():\n    session = requests.Session()\n    try:\n        # Step 1: Upload Excel file to /type2/upload/\n        excel_content = b\"PK\\x03\\x04\\x14\\x00\\x06\\x00\"  # Minimal valid zip header (xlsx is a zip file)\n        excel_file = io.BytesIO(excel_content)\n        excel_file.name = 'template.xlsx'\n        files = {'file': (excel_file.name, excel_file, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')}\n        \n        resp_upload_excel = session.post(f\"{BASE_URL}/type2/upload/\", files=files, timeout=TIMEOUT)\n        assert resp_upload_excel.status_code == 200, f\"Excel upload failed with status {resp_upload_excel.status_code}\"\n\n        # Step 2: Upload screenshots to /type2/upload-screenshots/\n        # Prepare two minimal PNG files in memory\n        png_header = (\n            b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01'\n            b'\\x08\\x06\\x00\\x00\\x00\\x1f\\x15\\xc4\\x89\\x00\\x00\\x00\\nIDATx\\xdacd\\xf8\\x0f'\n            b'\\x00\\x01\\x01\\x01\\x00\\x18\\xdd\\xdc\\xdc\\x00\\x00\\x00\\x00IEND\\xaeB`\\x82'\n        )\n        screenshot1 = io.BytesIO(png_header)\n        screenshot1.name = 'screenshot1.png'\n        screenshot2 = io.BytesIO(png_header)\n        screenshot2.name = 'screenshot2.png'\n        files = [\n            ('files', (screenshot1.name, screenshot1, 'image/png')),\n            ('files', (screenshot2.name, screenshot2, 'image/png'))\n        ]\n        \n        resp_upload_screenshots = session.post(f\"{BASE_URL}/type2/upload-screenshots/\", files=files, timeout=TIMEOUT)\n        assert resp_upload_screenshots.status_code == 200, f\"Screenshots upload failed with status {resp_upload_screenshots.status_code}\"\n\n        # Step 3: Generate report at /type2/generate-report/\n        payload = {\n            \"client_name\": \"Test Client\",\n            \"client_code\": \"TC123\",\n            \"project_name\": \"VAPT Project\",\n            \"assessment_date\": \"2025-08-30\",\n            \"report_type\": \"Type-2\"\n        }\n        headers = {\"Content-Type\": \"application/json\"}\n        resp_generate = session.post(f\"{BASE_URL}/type2/generate-report/\", json=payload, headers=headers, timeout=TIMEOUT)\n        assert resp_generate.status_code == 200, f\"Report generation failed with status {resp_generate.status_code}\"\n        json_response = resp_generate.json()\n        \n        # Validate JSON keys expected in a successful report generation response\n        # Assuming response contains keys such as 'report_url' or 'message'\n        assert (\"report_url\" in json_response or \"message\" in json_response), \"Missing expected keys in report generation response\"\n        if \"message\" in json_response:\n            assert \"success\" in json_response[\"message\"].lower(), \"Report generation message does not indicate success\"\n    except (RequestException, Timeout) as e:\n        assert False, f\"Request failed: {e}\"\n\nvalidate_type2_report_generation_workflow()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 60, in <module>\n  File \"<string>\", line 49, in validate_type2_report_generation_workflow\nAssertionError: Report generation failed with status 422\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-03T13:43:30.581Z",
    "modified": "2025-09-03T13:44:57.338Z"
  },
  {
    "projectId": "207d7387-450f-4eb5-b33d-4ff2a1539de3",
    "testId": "6bb24c0f-003e-464d-9167-c9bcba757159",
    "userId": "e4684458-5031-70c9-9355-46fd4a87f00e",
    "title": "TC004-dashboard_access_and_data_handling",
    "description": "Verify that the dashboard interface is accessible only to authorized users and that dataset uploads, listing, downloading, project history retrieval, updates, and audit log retrieval function correctly.",
    "code": "import requests\nfrom requests.exceptions import RequestException\nimport io\nimport json\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n# Placeholder credentials or token for authorized access\n# In real scenario, this should be replaced with actual auth flow and token retrieval\nAUTH_TOKEN = None\n\ndef get_auth_token():\n    \"\"\"\n    Simulate retrieval of an auth token or session cookie after Azure SSO login.\n    This function is a stub and should be adapted to the real auth mechanism.\n    For testing purposes, we assume authorization is done via a session cookie or bearer token.\n    \"\"\"\n    # For illustration, attempt to login and get a session cookie or token from /login or /auth/login\n    # Since the real auth flow involves redirects to Azure SSO, here we simulate a successful login with a dummy token.\n    # Replace with actual login code if available.\n    # Return session headers for authenticated requests.\n    return {\"Authorization\": \"Bearer dummy-authtoken\"}\n\ndef dashboard_access_and_data_handling():\n    headers = {}\n    global AUTH_TOKEN\n    # Get auth token/headers for authorized requests\n    AUTH_TOKEN = get_auth_token()\n    if AUTH_TOKEN:\n        headers.update(AUTH_TOKEN)\n\n    # 1. Access dashboard and verify access control\n    try:\n        # Unauthorized access check (without auth headers)\n        resp = requests.get(f\"{BASE_URL}/dashboard\", timeout=TIMEOUT, allow_redirects=False)\n        # Should redirect to login (302) for unauthorized or return 200 if public\n        assert resp.status_code in (200, 302), f\"Unauthorized access to /dashboard did not redirect or return 200, got {resp.status_code}\"\n\n        # Authorized access check (with auth headers)\n        resp = requests.get(f\"{BASE_URL}/dashboard\", headers=headers, timeout=TIMEOUT, allow_redirects=False)\n        assert resp.status_code == 200, f\"Authorized access to /dashboard failed with status {resp.status_code}\"\n        assert \"text/html\" in resp.headers.get(\"Content-Type\", \"\"), \"Dashboard response content type not HTML\"\n\n        # 2. Upload a dashboard dataset\n        # Create a dummy file in-memory\n        dummy_csv_content = \"column1,column2\\nvalue1,value2\\n\"\n        file_bytes = io.BytesIO(dummy_csv_content.encode(\"utf-8\"))\n        files = {\"file\": (\"test_dataset.csv\", file_bytes, \"text/csv\")}\n        data = {\n            \"title\": \"Test Dataset\",\n            \"project_name\": \"Test Project\"\n        }\n        resp = requests.post(f\"{BASE_URL}/type1/dashboard/upload\", headers=headers, files=files, data=data, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Dataset upload failed with status {resp.status_code}\"\n        resp_json = resp.json() if resp.headers.get(\"Content-Type\",\"\").startswith(\"application/json\") else {}\n        # The API doc does not specify response body; just check for success status\n\n        # 3. List dashboard datasets and find the uploaded dataset\n        resp = requests.get(f\"{BASE_URL}/type1/dashboard-datasets\", headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Dashboard datasets listing failed with status {resp.status_code}\"\n        datasets = resp.json()\n        assert isinstance(datasets, list), \"Dashboard datasets response is not a list\"\n        # Try to find the dataset named \"Test Dataset\"\n        dataset_id = None\n        for ds in datasets:\n            if isinstance(ds, dict) and ds.get(\"title\") == \"Test Dataset\" and ds.get(\"project_name\") == \"Test Project\":\n                dataset_id = ds.get(\"id\") or ds.get(\"dataset_id\") or ds.get(\"datasetId\")\n                break\n        assert dataset_id is not None, \"Uploaded dataset not found in datasets list\"\n\n        # 4. Download the uploaded dataset file\n        resp = requests.get(f\"{BASE_URL}/type1/dashboard-datasets/{dataset_id}/file\", headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Failed to download dataset {dataset_id}, status {resp.status_code}\"\n        content_disp = resp.headers.get(\"Content-Disposition\", \"\")\n        assert \"attachment\" in content_disp or resp.headers.get(\"Content-Type\") == \"text/csv\", \"Downloaded dataset does not seem to be a file\"\n        file_content = resp.content\n        assert len(file_content) > 0, \"Downloaded dataset file is empty\"\n\n        # 5. Retrieve project history\n        resp = requests.get(f\"{BASE_URL}/type1/project-history\", headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Project history retrieval failed with status {resp.status_code}\"\n        project_history = resp.json()\n        assert isinstance(project_history, (list, dict)), \"Project history response format unexpected\"\n\n        # 6. Update project history\n        update_data = {\n            \"project_data\": {\n                \"project_name\": \"Test Project\",\n                \"update_note\": \"Automated test update\"\n            }\n        }\n        resp = requests.post(f\"{BASE_URL}/type1/project-history/update\", headers={**headers, \"Content-Type\": \"application/json\"},\n                             data=json.dumps(update_data), timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Project history update failed with status {resp.status_code}\"\n\n        # 7. Retrieve audit logs\n        resp = requests.get(f\"{BASE_URL}/type1/audit-logs\", headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Audit logs retrieval failed with status {resp.status_code}\"\n        audit_logs = resp.json()\n        assert isinstance(audit_logs, (list, dict)), \"Audit logs response format unexpected\"\n\n    except RequestException as e:\n        assert False, f\"HTTP Request failed: {e}\"\n\n\ndashboard_access_and_data_handling()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 107, in <module>\n  File \"<string>\", line 55, in dashboard_access_and_data_handling\nAssertionError: Dataset upload failed with status 403\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-03T13:43:30.588Z",
    "modified": "2025-09-03T13:45:09.495Z"
  },
  {
    "projectId": "207d7387-450f-4eb5-b33d-4ff2a1539de3",
    "testId": "7fc6aa35-4741-49c0-86f1-eb272f2d4db6",
    "userId": "e4684458-5031-70c9-9355-46fd4a87f00e",
    "title": "TC005-health_check_endpoint_functionality",
    "description": "Test the health check endpoint to ensure it reliably reports the service and database connectivity status with correct response structure.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_health_check_endpoint_functionality():\n    url = f\"{BASE_URL}/health\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to health endpoint failed: {e}\"\n\n    # Validate status code\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    # Validate response content type\n    content_type = response.headers.get(\"Content-Type\", \"\")\n    assert \"application/json\" in content_type, f\"Expected JSON response, got {content_type}\"\n\n    # Validate response JSON schema and values\n    json_data = response.json()\n    expected_keys = {\"status\", \"service\", \"database\"}\n    actual_keys = set(json_data.keys())\n    assert expected_keys == actual_keys, f\"Response keys mismatch. Expected {expected_keys}, got {actual_keys}\"\n\n    # Validate that status, service and database are non-empty strings\n    for key in expected_keys:\n        value = json_data.get(key)\n        assert isinstance(value, str) and len(value) > 0, f\"Key '{key}' should be a non-empty string\"\n\ntest_health_check_endpoint_functionality()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-03T13:43:30.593Z",
    "modified": "2025-09-03T13:44:03.080Z"
  },
  {
    "projectId": "207d7387-450f-4eb5-b33d-4ff2a1539de3",
    "testId": "86b824aa-7d01-41f5-8e49-7bc9a7dd21fa",
    "userId": "e4684458-5031-70c9-9355-46fd4a87f00e",
    "title": "TC006-static_file_serving_endpoints",
    "description": "Verify that static files and automation files are served correctly via their respective endpoints and that the report formats page loads successfully.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\nHEADERS = {\n    \"Accept\": \"*/*\"\n}\n\ndef test_static_file_serving_endpoints():\n    # Test static file serving\n    static_file = \"dashboard.html\"  # Changed to a likely existing static file from PRD\n    static_url = f\"{BASE_URL}/static/{static_file}\"\n    try:\n        static_resp = requests.get(static_url, headers=HEADERS, timeout=TIMEOUT)\n        assert static_resp.status_code == 200, f\"Static file {static_file} not served correctly\"\n        assert static_resp.content, \"Static file response content is empty\"\n    except requests.RequestException as e:\n        assert False, f\"Request to static file endpoint failed: {e}\"\n\n    # Test automation file serving\n    automation_file = \"test.html\"  # From PRD files, Automation/test.html should exist\n    automation_url = f\"{BASE_URL}/Automation/{automation_file}\"\n    try:\n        automation_resp = requests.get(automation_url, headers=HEADERS, timeout=TIMEOUT)\n        assert automation_resp.status_code == 200, f\"Automation file {automation_file} not served correctly\"\n        assert automation_resp.content, \"Automation file response content is empty\"\n    except requests.RequestException as e:\n        assert False, f\"Request to automation file endpoint failed: {e}\"\n\n    # Test report_formats.html page loads successfully\n    report_formats_url = f\"{BASE_URL}/report_formats.html\"\n    try:\n        report_formats_resp = requests.get(report_formats_url, headers=HEADERS, timeout=TIMEOUT)\n        assert report_formats_resp.status_code == 200, \"Report formats page did not load successfully\"\n        # Check if content-type is HTML\n        content_type = report_formats_resp.headers.get(\"Content-Type\", \"\")\n        assert \"text/html\" in content_type, f\"Unexpected content-type for report_formats.html: {content_type}\"\n        assert report_formats_resp.text.strip(), \"Report formats page content is empty\"\n    except requests.RequestException as e:\n        assert False, f\"Request to report_formats.html failed: {e}\"\n\ntest_static_file_serving_endpoints()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 42, in <module>\n  File \"<string>\", line 15, in test_static_file_serving_endpoints\nAssertionError: Static file dashboard.html not served correctly\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-03T13:43:30.600Z",
    "modified": "2025-09-03T13:44:38.298Z"
  }
]
